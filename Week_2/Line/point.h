//Listing 2.1. Файл Point.h: определение класса Point 

#ifndef POINT_H
#define POINT_H 



class Point //заголовок описания класса Point  
{ //начало закрытой (по умолчанию) части класса 

private: //спецификатор закрытой части (секции) класса 

	int x_, y_; //члены-данные (свойства) класса (подчеркивание в 
	//конце – это современные рекомендации экспертов) 

public: //спецификатор открытой части - интерфейса класса 

	//** 1 **минимальный интерфейс класса 
	//объявленные ниже методы доступа (методы-аксессоры) 
	// Get...() и Set...() образуют минимальный интерфейс класса 

	int GetX() const //член-функция (метод) для чтения компонента х_ 
	{ //определение метода в классе неявно объявляет его 
		return x_; // встроенным (inline) (лучше этого избегать) 
	}

	int GetY() const; //это прототип метода, а его определение находится  
	//здесь же, но после описания класса (так лучше) 
	void SetX(int); //метод для установки значения компонента х_, 
	//определение его и всех остальных методов 
	void SetY(int); //размещается в файле реализации Point.cpp 

	//** 2 ** методы, расширяющие функциональность класса 

	void Print(); //печать координат точки 
	//в формате (x,y) 
	bool Read(const char* = 0); //ввод с клавиатуры 
	//(с подсказкой) 
	void Move(int delta_x, int delta_y); //относительное перемещение 
	//(от текущей позиции) 
	double Dist(const Point&); //расстояние между точками 
	//(имеет один аргумент!) 

	//** 3 ** внешняя функция, объявленная дружественной к классу 

	friend double fdist(const Point&, const Point&);//расстояние 
	// специальные методы класса: конструкторы и деструкторы
	// если конструктор или деструктор не создавать то они прописываются
	// компилятором
	Point() /*{}*/; // конструктор по умолчанию. Если явное не прописан, то пропишется компилятором
	Point(const Point &); // конструктор копирования. Компилятор создает автоматически Если нет явно
	Point(int, int); // явный конструктор. Нужно прописывать явно
	explicit // только явно без приведения типов
	Point(int); // конструктор преобраования
	//Point(int = 0, int = 0); // конструктор 3 в 1
	~Point() /*{}*/; // деструктор
	// оператр присваивания
	Point &operator =(const Point &);
};

//Определение встроенной функции должно быть видимым компилятору в точке 
//ее вызова, по этой причине оно расположено в заголовочном файле. 
//Имена функций-членов, определяемых вне контекста класса, должны быть 
//полностью квалифицированы (уточнены) при помощи бинарного оператора :: 

inline int Point::GetY() const //здесь inline надо объявлять явно 
{
	return y_;
}

#endif 
